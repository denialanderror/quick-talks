SQLC
---
### What?

- Type-safe SQL compiler
- Takes native SQL and automagically creates Go functions for calling the queries and structs for the input and output
- Essentially the opposite of an ORM - instead of writing the code and the query being generated for you, you write the 
  query and then use the output to write the code

### Why?

- Retrofitting a new ORM over a legacy code base (built with a different ORM) would be challenging
- ORMs can lead to confusing data models and hide poor choices
- However, SQL queries are sent to the database as strings, so provide little native type safety (aside from throwing errors at runtime)
- SQLC provides static, compile-time safety over native SQL
- Easier to test

### How?

- sqlc.yaml config file - specify the location of the schema, queries and drivers
- Schema can include migration files, which SQLC applies internally when generating to validate the queries
- Queries are written in normal SQL (flavour of your choice), with the only difference being placeholders are given as $
  and a comment is required above every query specifying the name and arity (i.e. what it returns)
- Run SQLC's generate command  to produce the models and functions in the Store

### Demo

**Scenario:** We want this year's invoices for a client, in date order

#### Step 1
Create a new SQL file in `store.queries`. The name of the file will dictate the name of the generated `sql.go` file, though
this doesn't actually have any meaningful impact, as all queries will be available on the `Queries` struct anyway.

#### Step 2
Write a SQL query, ensuring any params are giving as a dollar followed by its position, e.g. `$1`. Give it a name and 
arity in the header comment. For instance:

 ```sql
 -- name: ThisYearsInvoices :many
  SELECT i.reference, i.amount, i.startdate
  FROM finance_client fc
  JOIN invoice i ON fc.id = i.finance_client_id
  WHERE fc.client_id = $1
  AND DATE_PART('year', i.startdate) = DATE_PART('year', $2)
  ORDER BY startdate;
  ```

#### Step 3
Generate the code by running the generate function - in this project, use `make sqlc-gen`. This will create a `sql.go` 
file, containing a function with the name you specified in the comment, as well as input and output structs. 

The query is a member function of `Queries`, which is code generated by SQLC in `db.go`. Make this struct available in
the service and call the query with the typed structs.

### Internals

As it is generated code, it is easy to inspect to see what it is doing, and this shows it is actually doing very little!
The generated code is simply a wrapper around Golang's SQL interface. All it is doing is adding guards to the query with
types and mapping the returned values for us!

### Links

* [SQLC](https://docs.sqlc.dev/en/latest/)
